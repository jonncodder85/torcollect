// Generated by CoffeeScript 1.6.3
(function() {
  var add_dot, data, generate_dots, generate_reportlink, get_date_array, get_nth_key, get_point, get_point_string, get_points, get_user_array, get_x_position, get_y_position, graph_height, graph_width, initialize_graph, keys, load_day_report, load_most_recent, maxim, values, x_space_between_points, y_space_between_points,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  data = graphdata;

  graph_width = function() {
    return document.getElementById("graphspace").clientWidth;
  };

  x_space_between_points = function() {
    return graph_width() / (data.length - 1);
  };

  get_x_position = function(count) {
    return Math.round(count * x_space_between_points());
  };

  y_space_between_points = function() {
    return graph_height() / maxim(get_user_array(data));
  };

  get_y_position = function(value) {
    return Math.round(graph_height() - value * y_space_between_points());
  };

  graph_height = function() {
    return 100;
  };

  get_point = function(value, count) {
    return [get_x_position(count), get_y_position(value)];
  };

  get_point_string = function(value, count) {
    return get_point(value, count)[0] + "," + get_point(value, count)[1];
  };

  maxim = function(data, i) {
    if (i == null) {
      i = 0;
    }
    if (i + 1 === data.length) {
      return Math.max(-Infinity, data[i]);
    } else {
      return Math.max(data[i], maxim(data, i + 1));
    }
  };

  values = function(dictionary) {
    var k, v, _results;
    _results = [];
    for (k in dictionary) {
      v = dictionary[k];
      _results.push(v);
    }
    return _results;
  };

  keys = function(dictionary) {
    var k, v, _results;
    _results = [];
    for (k in dictionary) {
      v = dictionary[k];
      _results.push(k);
    }
    return _results;
  };

  get_user_array = function(data) {
    var set, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      set = data[_i];
      _results.push(set['u']);
    }
    return _results;
  };

  get_date_array = function(data) {
    var set, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      set = data[_i];
      _results.push(set['d']);
    }
    return _results;
  };

  get_points = function(data, area) {
    var i, points;
    if (area == null) {
      area = true;
    }
    points = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = data.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(get_point_string(data[i], i));
      }
      return _results;
    })();
    if (area) {
      points.unshift(0 + "," + graph_height());
      points.push(graph_width() + "," + graph_height());
    }
    return points.join(" ");
  };

  get_nth_key = function(n) {
    return 1;
  };

  generate_reportlink = function(day) {
    return function() {
      alert("link klixxord" + day);
      return load_day_report(day);
    };
  };

  add_dot = function(svg, count, data) {
    var circle;
    circle = document.createElementNS(svg.namespaceURI, 'circle');
    circle.setAttribute("cx", get_x_position(count));
    circle.setAttribute("cy", get_y_position(data['u']));
    circle.setAttribute("r", 10);
    circle.setAttribute("stroke", "#aaff00");
    circle.setAttribute("stroke-width", 1);
    circle.setAttribute("fill", "#0f0");
    circle.setAttribute("xmlns:xlink", "load_day_report(day);");
    return svg.appendChild(circle);
  };

  generate_dots = function(svg, data) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = data.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(add_dot(svg, i, data[i]));
    }
    return _results;
  };

  initialize_graph = function() {
    var polygon, sns, svg, vals;
    vals = get_user_array(data);
    svg = document.getElementById('tc_graph');
    svg.setAttribute('width', graph_width());
    sns = svg.namespaceURI;
    polygon = document.createElementNS(sns, 'polygon');
    polygon.setAttribute("points", get_points(vals));
    polygon.setAttribute("fill", "url(#grad1)");
    svg.appendChild(polygon);
    return generate_dots(svg, data);
  };

  load_day_report = function(day) {
    var req, url;
    if (typeof this.XMLHttpRequest === "undefined") {
      console.log('XMLHttpRequestis undefined');
      this.XMLHttpRequest = function() {
        var error;
        try {
          return new ActiveXObject("Msxml2.XMLHTTP.6.0");
        } catch (_error) {
          error = _error;
        }
        try {
          return new ActiveXObject("Msxml2.XMLHTTP.3.0");
        } catch (_error) {
          error = _error;
        }
        try {
          return new ActiveXObject("Microsoft.XMLHTTP");
        } catch (_error) {
          error = _error;
        }
        throw new Error("This browser does not support XMLHttpRequest.");
      };
    }
    req = new XMLHttpRequest();
    req.addEventListener('readystatechange', function() {
      var success_resultcodes, _ref;
      if (req.readyState === 4) {
        success_resultcodes = [200, 304];
        if (_ref = req.status, __indexOf.call(success_resultcodes, _ref) >= 0) {
          return document.getElementById('reportcontent').innerHTML = req.responseText;
        }
      }
    });
    url = '/reports/' + day + '.html';
    req.open('GET', url, true);
    return req.send(null);
  };

  load_most_recent = function(data) {
    return load_day_report(get_date_array(data)[data.length - 1]);
  };

  initialize_graph(data);

  load_most_recent(data);

}).call(this);
